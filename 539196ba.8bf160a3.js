(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{119:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),p=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},b=function(e){var t=p(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},f=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),b=p(n),f=a,m=b["".concat(s,".").concat(f)]||b[f]||u[f]||o;return n?r.a.createElement(m,i(i({ref:t},l),{},{components:n})):r.a.createElement(m,i({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=f;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},80:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var a=n(2),r=n(6),o=(n(0),n(119)),s={id:"effects",title:"Effects"},i={unversionedId:"basics/effects",id:"basics/effects",isDocsHomePage:!1,title:"Effects",description:"Rx Store effects are functions that return observables. Rx Store subscribes to these for you.",source:"@site/docs/basics/effects.md",permalink:"/rx-store/docs/next/basics/effects",editUrl:"https://github.com/rx-store/rx-store/tree/master/apps/rx-store-website/docs/basics/effects.md",version:"next",sidebar:"someSidebar",previous:{title:"Observables",permalink:"/rx-store/docs/next/basics/observables"},next:{title:"Installation",permalink:"/rx-store/docs/next/react/react-installation"}},c=[{value:"Processing a stream of changes, and creating a stream of state",id:"processing-a-stream-of-changes-and-creating-a-stream-of-state",children:[]},{value:"Effects that manipulate time",id:"effects-that-manipulate-time",children:[]},{value:"Recursive effects",id:"recursive-effects",children:[]},{value:"Combining data producers in complex ways",id:"combining-data-producers-in-complex-ways",children:[]},{value:"Nesting multiple effects",id:"nesting-multiple-effects",children:[]},{value:"Other Examples",id:"other-examples",children:[{value:"Example 1",id:"example-1",children:[]},{value:"Example 2",id:"example-2",children:[]},{value:"Example 3",id:"example-3",children:[]}]}],l={rightToc:c};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Rx Store")," effects are functions that return observables. Rx Store ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://rxjs-dev.firebaseapp.com/guide/subscription"}),"subscribes")," to these for you."),Object(o.b)("hr",null),Object(o.b)("p",null,"Each store has only one root effect, you may nest effects with Rx operators, building a tree of effects your data flows through, triggering side effects as the data flows!"),Object(o.b)("p",null,"Effects will normally produce side effects, or handle some cross cutting concern. Effects are long lived, until your store is torn down & disposed of. You can use filtering operators in RxJS such as ",Object(o.b)("inlineCode",{parentName:"p"},"skipWhile()"),", ",Object(o.b)("inlineCode",{parentName:"p"},"takeUntil()")," to use other streams in the store to control & limit when & how your effect does work."),Object(o.b)("h2",{id:"processing-a-stream-of-changes-and-creating-a-stream-of-state"},"Processing a stream of changes, and creating a stream of state"),Object(o.b)("p",null,"Here is an effect that reacts to the ",Object(o.b)("inlineCode",{parentName:"p"},"counterChange$"),", each time it emits ",Object(o.b)("inlineCode",{parentName:"p"},"1")," or ",Object(o.b)("inlineCode",{parentName:"p"},"-1"),", it'll add that to an accumulator with a ",Object(o.b)("inlineCode",{parentName:"p"},"scan()")," operator, and emit the running total onto the ",Object(o.b)("inlineCode",{parentName:"p"},"count$")," sink."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export const effect = ({sources, sinks}) =>\n  sources.counterChange$()\n    .pipe(\n      scan((acc, val) => acc + val, 0)\n      startWith(0),\n      sinks.count$()\n    )\n};\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Sources")," are like the inputs, where the data flows from Rx Store into the effect. ",Object(o.b)("inlineCode",{parentName:"p"},"Sinks")," are like the outputs, where the data can flow out of the effect (back into your Rx Store). Separating the sources and sinks allows Rx Store to track all data flow in your app, enabling things such as devtools to assist in debugging."),Object(o.b)("h2",{id:"effects-that-manipulate-time"},"Effects that manipulate time"),Object(o.b)("p",null,"Here is an effect that subscribes to the ",Object(o.b)("inlineCode",{parentName:"p"},"count$")," source, it delays each value by one second, and logs them to console as a side effect."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export const effect = ({ sources }) =>\n  sources.count$().pipe(delay(1000), tap(console.log));\n")),Object(o.b)("h2",{id:"recursive-effects"},"Recursive effects"),Object(o.b)("p",null,"Here is an effect that resets the count back to 1 with a 50% probability anytime it emits. Be careful not to create an infinite loop by having a stream recursively emit back onto itself with 100% probability, with no base case to stop it!"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export const effect = ({sources, sinks}) =>\n  sources.count$().pipe(\n    filter((count) => Math.random() > 0.5 && count !== 1))\n    sinks.count$()\n  )\n")),Object(o.b)("h2",{id:"combining-data-producers-in-complex-ways"},"Combining data producers in complex ways"),Object(o.b)("p",null,"We can subscribe directly to subjects, observables, or create combos and higher order streams by combining them and using creation operators such as ",Object(o.b)("inlineCode",{parentName:"p"},"merge()"),", ",Object(o.b)("inlineCode",{parentName:"p"},"combineLatest()"),", and higher order operators such as ",Object(o.b)("inlineCode",{parentName:"p"},"bufferWhen()"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export const effect = ({ sources }) =>\n  merge(sources.myClick$(), sources.yourClick$()).pipe(\n    tap((clickEvent) => {\n      console.log({ clickEvent });\n    })\n  );\n")),Object(o.b)("h2",{id:"nesting-multiple-effects"},"Nesting multiple effects"),Object(o.b)("p",null,"If you want multiple effects & subscriptions, it is up to you to nest them using RxJs operators. Rx Store just expects to have one root subscription, and it does not care about values emitted on this subscription. Each effect is passed a ",Object(o.b)("inlineCode",{parentName:"p"},"spawnEffect")," function which allows ",Object(o.b)("inlineCode",{parentName:"p"},"Rx Store"),' to track the parent child relationship between effects, essentially keeping an internal "stack trace" of effects.'),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"export const appRootEffect = ({ spawnEffect }) =>\n  merge(\n    spawnEffect(time, { name: 'time' }),\n    spawnEffect(counter, { name: 'counter' })\n  );\n")),Object(o.b)("h2",{id:"other-examples"},"Other Examples"),Object(o.b)("h3",{id:"example-1"},"Example 1"),Object(o.b)("p",null,"Your effect will more commonly emit onto some other subject, for example you might often subscribe to a ",Object(o.b)("inlineCode",{parentName:"p"},"request$")," subject in your effect, and for each value emitted on that ",Object(o.b)("inlineCode",{parentName:"p"},"subject")," you might start a network request, and you might emit the responses onto a ",Object(o.b)("inlineCode",{parentName:"p"},"response$")," subject."),Object(o.b)("h3",{id:"example-2"},"Example 2"),Object(o.b)("p",null,'In a social network app you may have "trigger" effect, for example a ',Object(o.b)("inlineCode",{parentName:"p"},"refetchNewsFeed$")," subject, when the user scrolls up a value is emitted on this subject, which triggers an effect to fetch the latest news feed posts & emit them onto a ",Object(o.b)("inlineCode",{parentName:"p"},"newsFeedPost$")," subject, a stream of the latest news feed posts."),Object(o.b)("h3",{id:"example-3"},"Example 3"),Object(o.b)("p",null,'In a video game, you might have a "game loop" effect wherein you subscribe to the latest ',Object(o.b)("inlineCode",{parentName:"p"},"x$"),", ",Object(o.b)("inlineCode",{parentName:"p"},"y$")," mouse position, and a stream of the latest ",Object(o.b)("inlineCode",{parentName:"p"},"click$"),". You might emit onto a stream of ",Object(o.b)("inlineCode",{parentName:"p"},"hit$")," & ",Object(o.b)("inlineCode",{parentName:"p"},"miss$")," depending on if the latest values on the ",Object(o.b)("inlineCode",{parentName:"p"},"x$"),", ",Object(o.b)("inlineCode",{parentName:"p"},"y$")," streams collide with any enemy positions at the points in time that the ",Object(o.b)("inlineCode",{parentName:"p"},"click$")," stream emitted values. Furthermore you might skip emitting these values while the ",Object(o.b)("inlineCode",{parentName:"p"},"ammo$")," stream has 0 values, by using RxJs control flow operators such as ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://rxjs-dev.firebaseapp.com/api/operators/takeUntil"}),"takeUntil")))}p.isMDXComponent=!0}}]);