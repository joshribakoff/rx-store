(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{181:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var a=n(0),r=n.n(a);function c(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){c(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},c=Object.keys(e);for(a=0;a<c.length;a++)n=c[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(a=0;a<c.length;a++)n=c[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),i=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},u=function(e){var t=i(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},f=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,c=e.originalType,s=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),u=i(n),f=a,h=u["".concat(s,".").concat(f)]||u[f]||b[f]||c;return n?r.a.createElement(h,p(p({ref:t},l),{},{components:n})):r.a.createElement(h,p({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var c=n.length,s=new Array(c);s[0]=f;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:a,s[1]=p;for(var l=2;l<c;l++)s[l]=n[l];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},88:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return p})),n.d(t,"rightToc",(function(){return o})),n.d(t,"default",(function(){return i}));var a=n(2),r=n(6),c=(n(0),n(181)),s={id:"autocomplete",title:"Autocomplete App"},p={unversionedId:"react/guides/autocomplete",id:"react/guides/autocomplete",isDocsHomePage:!1,title:"Autocomplete App",description:"Create a React app",source:"@site/docs/react/guides/autocomplete.md",permalink:"/rx-store/docs/react/guides/autocomplete",editUrl:"https://github.com/rx-store/rx-store/tree/master/apps/rx-store-website/docs/react/guides/autocomplete.md",sidebar:"react",previous:{title:"Counter App",permalink:"/rx-store/docs/react/guides/counter"},next:{title:"store()",permalink:"/rx-store/docs/react/api-reference/store"}},o=[{value:"Create a React app",id:"create-a-react-app",children:[]},{value:"Store Value (subjects)",id:"store-value-subjects",children:[]},{value:"API Helper",id:"api-helper",children:[]},{value:"Effect",id:"effect",children:[]},{value:"Spawn Effects",id:"spawn-effects",children:[]},{value:"Create Store",id:"create-store",children:[]},{value:"Wrap App in the &lt;Manager&gt;",id:"wrap-app-in-the-manager",children:[]},{value:"Text Input &amp; Suspense Results",id:"text-input--suspense-results",children:[]}],l={rightToc:o};function i(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(c.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(c.b)("h2",{id:"create-a-react-app"},"Create a React app"),Object(c.b)("p",null,"We'll assume you already have a React app setup, if not ",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/create-a-new-react-app.html"}),"create one now"),", ",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"/rx-store/docs/react/react-installation"}),"and install ",Object(c.b)("inlineCode",{parentName:"a"},"Rx Store")),". We'll use ",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://reactjs.org/docs/create-a-new-react-app.html#create-react-app"}),"create react app"),". You'll also need to install the Giphy JS SDK and ",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://developers.giphy.com/"}),"create an API key")," to follow this tutorial."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{}),"npx create-react-app rx-store-autocomplete-test --template typescript\nyarn add @rx-store/react @rx-store/core rxjs @giphy/js-fetch-api\n")),Object(c.b)("h2",{id:"store-value-subjects"},"Store Value (subjects)"),Object(c.b)("p",null,"The store value is where we'll store our sources of truth. We'll use two ",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://rxjs-dev.firebaseapp.com/guide/subject"}),"subjects"),", one called ",Object(c.b)("inlineCode",{parentName:"p"},"searchInput$")," which emits a string with the latest values of the text input, and one called ",Object(c.b)("inlineCode",{parentName:"p"},"resultImage$")," that emits an object of the shape ",Object(c.b)("inlineCode",{parentName:"p"},"{url: string}")," each time we get back a result from the API."),Object(c.b)("p",null,"We'll declare the typings here, but if you're not using typescript you can skip this step."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"interface AppStoreValue extends StoreValue {\n  searchInput$: Subject<string>;\n  resultImage$: Subject<undefined | ResultImage>;\n}\n")),Object(c.b)("p",null,"Next, we'll implement this interface, or create the store value. For both subjects we will ",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://rxjs-dev.firebaseapp.com/guide/subject#behaviorsubject"}),"BehaviorSubject")," so they act stateful."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const storeValue: AppStoreValue = {\n  searchInput$: new BehaviorSubject(''),\n  resultImage$: new BehaviorSubject<undefined | ResultImage>(undefined),\n};\n")),Object(c.b)("h2",{id:"api-helper"},"API Helper"),Object(c.b)("p",null,"We'll create a helper function that takes in a search term, and returns a promise that eventually resolves to an object of shape ",Object(c.b)("inlineCode",{parentName:"p"},"{url: string}"),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const fetchGif = async (searchInput: string) => {\n  const result = await gf.search(searchInput, { limit: 1 });\n  const images = result.data.map((data) =>\n    Object.entries(data.images).find(([key]) => key === 'preview_gif')\n  );\n  if (images.length === 0) {\n    return undefined;\n  } else {\n    if (images[0]?.length) return images[0][1];\n    return undefined;\n  }\n};\n")),Object(c.b)("h2",{id:"effect"},"Effect"),Object(c.b)("p",null,"We'll write an effect that takes the ",Object(c.b)("inlineCode",{parentName:"p"},"searchInput$")," events, and ",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://rxjs-dev.firebaseapp.com/api/operators/debounceTime"}),"debounces")," them for 1.2 seconds, then converts them to network request and cancels any previous in flight request with ",Object(c.b)("a",Object(a.a)({parentName:"p"},{href:"https://rxjs-dev.firebaseapp.com/api/operators/switchMap"}),"switchMap"),"."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const effect: Effect<AppStoreValue> = ({ sources, sinks, spawnEffect }) =>\n  sources.searchInput$().pipe(\n    debounceTime(1200),\n    switchMap((searchInput) =>\n      return fetchGif(searchInput)\n    ),\n    sinks.resultImage$()\n  );\n")),Object(c.b)("h2",{id:"spawn-effects"},"Spawn Effects"),Object(c.b)("p",null,"If we want, instead of having one effect like in the previous examlpe, we wrap part of the root effect's observable sequence in ",Object(c.b)("inlineCode",{parentName:"p"},"spawnEffect"),", which allows Rx Store to track the lifecycle of the subscriptions to the inner effect, for use cases such as devtools and more granular logging."),Object(c.b)("p",null,"Here we have also added random amounts of delay within the inner effect and we have given it a name of ",Object(c.b)("inlineCode",{parentName:"p"},"fetch-effect")," which is how Rx Store will internally identify the effect. It is a good idea to break the effects up to modularize your logic."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-ts"}),"const createFetchEffect = (searchInput: string) => () => {\n  return from(fetchGif(searchInput)).pipe(delay(1000 + Math.random() * 5000));\n};\n\nconst effect: Effect<AppStoreValue> = ({ sources, sinks, spawnEffect }) =>\n  sources.searchInput$().pipe(\n    debounceTime(1200),\n    switchMap((searchInput) =>\n      spawnEffect(createFetchEffect(searchInput), { name: 'fetch-effect' })\n    ),\n    sinks.resultImage$()\n  );\n")),Object(c.b)("h2",{id:"create-store"},"Create Store"),Object(c.b)("p",null,"We'll simply pass in the ",Object(c.b)("inlineCode",{parentName:"p"},"storeValue")," (subjects) and the ",Object(c.b)("inlineCode",{parentName:"p"},"effect")," to the ",Object(c.b)("inlineCode",{parentName:"p"},"store()")," method:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"const { Manager, context } = store({ value: storeValue, effect });\n")),Object(c.b)("h2",{id:"wrap-app-in-the-manager"},"Wrap App in the ","<","Manager",">"),Object(c.b)("p",null,"Next, we'll take the ",Object(c.b)("inlineCode",{parentName:"p"},"Manager")," component returned by the ",Object(c.b)("inlineCode",{parentName:"p"},"store()")," method & wrap our app with it:"),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"<Manager>\n  <>your app goes here</>\n</Manager>\n")),Object(c.b)("h2",{id:"text-input--suspense-results"},"Text Input & Suspense Results"),Object(c.b)("p",null,"We'll now implement the text input, which nexts values onto the ",Object(c.b)("inlineCode",{parentName:"p"},"searchInput$")," subject, which is received by our root effect. After some time, these are mapped to inner effects that eventually emit the results of the network request. Until the first value(s) arrive, React will suspend using the ",Object(c.b)("inlineCode",{parentName:"p"},"<Suspense />")," boundary. More robust React suspense patterns are under development."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),'export const App = () => {\n  const store = useStore(rootContext);\n  const [searchInput] = useSubscription(store.searchInput$);\n  const [resultImage] = useSubscription(store.resultImage$);\n  return (\n    <>\n      <input\n        type="text"\n        value={searchInput || \'\'}\n        onChange={(event) => {\n          store.searchInput$.next(event.target.value);\n        }}\n      />\n      <br />\n      <Suspense fallback={<>suspended. wait.</>}>\n        <Result resultImage={resultImage} />\n      </Suspense>\n    </>\n  );\n};\n\nconst Result = ({ resultImage }: { resultImage?: ResultImage }) => {\n  if (!resultImage)\n    throw new Promise(() => {\n      //\n    });\n  return resultImage ? <img src={resultImage.url} alt="" /> : null;\n};\n\nexport default App;\n')))}i.isMDXComponent=!0}}]);